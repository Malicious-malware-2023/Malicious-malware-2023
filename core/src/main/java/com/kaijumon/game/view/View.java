package com.kaijumon.game.view;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.maps.MapLayer;
import com.badlogic.gdx.maps.MapLayers;
import com.badlogic.gdx.maps.tiled.TiledMap;
import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
import com.badlogic.gdx.maps.tiled.renderers.OrthogonalTiledMapRenderer;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.ScreenUtils;
import com.kaijumon.game.KaijumonGame;
import com.kaijumon.game.model.IModel;
import com.kaijumon.game.model.entities.Player;
import com.kaijumon.game.utils.Consts;

import java.awt.*;

import static com.badlogic.gdx.math.MathUtils.*;
import static java.lang.Math.max;
import static java.lang.Math.min;

public class View implements IView {

    private final Texture playerTexture;
    private final Texture grassTexture;
    private final KaijumonGame game;
    private final IModel model;
    private final OrthographicCamera camera;
    private final Point lastPlayerPos;
    private final MapLayers mapLayers;
    private final OrthogonalTiledMapRenderer tiledMapRenderer;


    public View(final KaijumonGame game, IModel model) {
        this.game = game;
        this.model = model;

        playerTexture = new Texture(Gdx.files.internal("player.jpg"));
        grassTexture = new Texture(Gdx.files.internal("grass.png"));

        camera = new OrthographicCamera();
        camera.setToOrtho(false, 800, 480);
        TiledMap tiledMap = model.getTileMap();
        tiledMapRenderer = new OrthogonalTiledMapRenderer(tiledMap, 2);
        mapLayers = tiledMap.getLayers();


        lastPlayerPos = new Point(model.getPlayer().getX(), model.getPlayer().getY());
    }

    @Override
    public void render(float delta) {
        ScreenUtils.clear(0, 0, 0, 1);

        camera.update();
        game.batch.setProjectionMatrix(camera.combined);
        tiledMapRenderer.setView(camera);

        drawMapBackground();
        game.batch.begin();
        Point playerPosition = calculatePlayerPos();
        game.batch.draw(
                playerTexture,
                playerPosition.x,
                playerPosition.y,
                Consts.tileSize,
                Consts.tileSize
        );
        camera.translate(calculateCameraPosition(playerPosition));
        game.batch.end();
        drawMapForeground();
    }

    /**
     * function to draw the background tiles
     * this is separate from the foreground tiles so that we can draw the player behind the foreground tiles
     * only tiles that have a 'isForeground' property and is visible will be drawn
     */
    private void drawMapBackground(){
        tiledMapRenderer.getBatch().begin();
        for (MapLayer layer : mapLayers) {
            boolean isForeground = layer.getProperties().containsKey("isForeground") && layer.getProperties().get("isForeground").equals(true);
            if (isForeground || !layer.isVisible())
                continue;
            tiledMapRenderer.renderTileLayer((TiledMapTileLayer) layer);

        }
        tiledMapRenderer.getBatch().end();
    }

    /**
     * function to draw the foreground tiles
     * this is separate from the background tiles so that we can draw the player behind the foreground tiles
     * only tiles that have a 'isForeground' property and is visible will be drawn
     */
    private void drawMapForeground(){
        tiledMapRenderer.getBatch().begin();
        for (MapLayer layer : mapLayers) {
            boolean isForeground = layer.getProperties().containsKey("isForeground") && layer.getProperties().get("isForeground").equals(true);
            if (!isForeground || !layer.isVisible())
                continue;
            tiledMapRenderer.renderTileLayer((TiledMapTileLayer) layer);

        }
        tiledMapRenderer.getBatch().end();
    }

    /**
     * Calculates the player sprite position based on the time since the last move
     * the player moves instantly in the model, so we need to interpolate the position of the sprite.
     * @return Point with the player sprite position
     */
    private Point calculatePlayerPos(){
        float timeSinceMoveStarted = System.currentTimeMillis() - model.getTimeSinceLastMove();
        Player player = model.getPlayer();

        if (timeSinceMoveStarted >= Consts.timeBetweenMovesMillis)
            lastPlayerPos.move(player.getX(), player.getY());

        if (lastPlayerPos.equals(player.getPosition()))
            return worldToScreen(player.getPosition());

        Point oldPos = new Point(worldToScreen(lastPlayerPos));
        Point newPos = new Point(worldToScreen(player.getPosition()));

        // Mapping from a time range to a position range, based on the time since the last move
        float clampedTime = clamp(timeSinceMoveStarted, 0, Consts.timeBetweenMovesMillis);
        int x = (int) map(0, Consts.timeBetweenMovesMillis, oldPos.x, newPos.x, clampedTime);
        int y = (int) map(0, Consts.timeBetweenMovesMillis, oldPos.y, newPos.y, clampedTime);
        return new Point(x, y);
    }

    private Vector2 calculateCameraPosition(Point playerPosition){

        float cameraMoveVectorX = playerPosition.x - camera.position.x;
        float cameraMoveVectorY = playerPosition.y - camera.position.y;

        Vector3 cameraBottomLeft = camera.frustum.planePoints[0];
        if (cameraBottomLeft.x < 0)
            cameraMoveVectorX = max(cameraMoveVectorX, 0);
        if (cameraBottomLeft.y < 0)
            cameraMoveVectorY = max(cameraMoveVectorY, 0);

        Vector3 cameraTopRight = camera.frustum.planePoints[2];

        int numTilesX = tiledMapRenderer.getMap().getProperties().get("width", Integer.class);
        int numTilesY = tiledMapRenderer.getMap().getProperties().get("height", Integer.class);

        Vector2 worldTopRight = new Vector2(numTilesX * Consts.tileSize ,numTilesY * Consts.tileSize );
        if (cameraTopRight.x > worldTopRight.x)
            cameraMoveVectorX = min(cameraMoveVectorX, 0);
        if (cameraTopRight.y > worldTopRight.y)
            cameraMoveVectorY = min(cameraMoveVectorY, 0);

        return new Vector2(cameraMoveVectorX, cameraMoveVectorY);

    }

    /**
     * Converts world coordinates to screen coordinates
     * @param worldPoint world coordinates
     * @return screen coordinates
     */
    private Point worldToScreen(Point worldPoint){
        return new Point(worldPoint.x * Consts.tileSize, worldPoint.y * Consts.tileSize);
    }

    @Override
    public void dispose() {
        playerTexture.dispose();
        grassTexture.dispose();
    }
}
